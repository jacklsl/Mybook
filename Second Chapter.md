# 2 游戏开发环境和关键技术

“极速跑酷”的设计与实现，需要多方面知识和技术的结合。这就要求我们必须充分了解游戏的开发环境和关键的技术。

## 2.1 游戏开发环境

表2-1游戏开发环境

| 操作系统 | Windows 7 |
| --- | --- |
| 平台 | Windows 7 |
| 开发环境 | UnrealEngine4 |
| 开发语言 | Blueprint，C++ |
| 测试 | PC |

## 2.2 关键技术

在本节，将对基于UnrealEngine4的游戏开发所涉及到的技术进行介绍。

### 2.2.1 “蓝图”简介

蓝图是一种可视化的游戏了脚本。开发人员通过对蓝图节点的操作，实现游戏的复杂功能。蓝图脚本系统，非常的强大，而且操作简便，不需要开发人员进行语言编程，实现游戏的复杂功能。

蓝图可以创建几乎游戏所需的各种元素，并且可以进行修改。

Games（游戏）：由游戏规则，游戏关卡，游戏人物，游戏界面，游戏玩家等组成。

Players（玩家）：由PlayerController，模型，碰撞体等组成。

Cameras（相机）：由Camera在关卡中进行实例化。

Input（输入） ：在项目设置中通过输入的设置，创建输入事件。

Items（道具） ：武器、法术、掉落物、触发器等。

Environments（环境） ： 创建物品，并生成物品。

\(1\)"蓝图"概述

Blueprints（蓝图）在虚幻引擎中是一种，特殊类型的资源，提供了一个简单，直观的编程界面。他为游戏开发人员提供了一种快速创建和迭代游戏的工具。蓝图摒弃传统编程模式，通过可视化的编程，实现游戏功能。

\(2\)"蓝图"工作原理

蓝图的编程是可视化的编程。蓝图是游戏的可视化脚本。游戏开发者，通过使用连线将Node（节点），Event（事件），Function（函数），Variable（变量）连接起来，实现某种功能。通过这种简单的编程方法，开发者能创建复杂的游戏功能。

\(3\)常见蓝图类型

最常见的 蓝图 类型是 Level Blueprints（关卡蓝图） 和 Class Blueprints（类蓝图） 。

1.Level Blueprints（关卡蓝图）

关卡蓝图是和关卡紧密联系的。每个关卡都有其自己的关卡蓝图，他可以对游戏关卡中的所有事物进行引用和操作，并且可使用Matinee Actor控制过场动画，管理关卡动态加载等一系列操作。对于关卡中的实例化类，关卡蓝图可以获取实例化了的引用，调用实例化类的事件以及变量，进而控制实例化类做出某些改变。

2.Class Blueprints（类蓝图）

类蓝图，非常类似于我们编程语言中的类，通过对类蓝图中的事件，函数，变量的使用和创建，得到我们所需要的类蓝图，通过实例化被使用。类蓝图作为交互式资源可以被广泛应用。游戏中的所有事物都可以使用类蓝图对其进行操作。

### 2.2.2 编程语言--Blueprint和C++

UnrealEngine引擎前几代，都是使用脚本沙盒语言——UnrealScript来进行编程的通过简单的GamePlay模式进行编程。进而减少对C++的使用，来开发游戏。

随着引擎的发展，脚本编程已经不能够满足，游戏开发的要求，并且阻碍了游戏的发展。因此，到2011年，UnrealEngine4游戏引擎使用C++进行编程。采用C++编程的具体原因如下：

\(1\) 随着游戏引擎的不断成长，完整的沙盒功能的脚本，会使游戏引擎变得复杂和庞大。这样将不利于游戏引擎的成长。

\(2\) 由于脚本语言的惯用法与对应的 C++ 模板，在表达方式和语意有很大的差异，使得C++与脚本之间的通讯变得很复杂。脚本的接口的扩展，使得C++与脚本之间的交流变得更加困难，这样不利于游戏的开发和游戏的更新，会对后期的游戏维护和更新带来毁灭性的灾难。

\(3\) 脚本语言的使用，导致脚本与代码切换，浪费了大量的时间，使得游戏执行变得缓慢，拖累了游戏的开发。

\(4\) 由于脚本调试工具和C++调试工具是独立的和不兼容的。因为我们无法跟踪C++程序，这样，当游戏发生错误时，我们很难判断，是脚本的原因或是C++程序的原因。个给游戏的开发有带来了一个难题。

综上所述，Epic最终采用了纯C++，作为游戏开发的编程语言。这样带来和很多的方便，让开发者从那些无聊而繁琐的地方，得到解放，使他们更加专注游戏的开发。游戏脚本的废除，让开发者更加专注与C++游戏的修改和扩展，使游戏开发的效率大大的提高了。

并不是说C++是一个很理想的游戏编程语言。比起UnrealScript，C\#，JavaScript，它有很多的复杂性，危险性。但反过来换一种方式说，C++更加强大。

Epic采用纯C++,是进行过多方面的考虑的。准确来所，C++并不是一种很好的游戏编程语言。C++的灵活性很好，但却也有很大的复杂性，这样在游戏开发的时候危险性却也很大。在C++编程时，开发者必须更加的谨慎。

C++的强大，可以让开发者在游戏开发时，有很大的灵活性，并且可以打破很多编程时的限制。通过底层代码的修改，开发者们甚至可以和操作系统层，高级第三方库进行打交道。

蓝图可以继承C++类，从而使得程序员可以在代码中创建新的游戏性类，而关卡设计人员可以使用蓝图来继承该类并对其进行修改。通过对C++类的编译可获得蓝图类。

### 2.2.3 Gameplay框架

游戏的框架由不同的部分进行相互间的交流和沟通而构成。游戏框架各部分负责不的功能，他们既分工又合作完成游戏的运行，就像工厂里的工人一样。游戏的架构就是通过分工合作来构建起来的。如PlayerController，它只负责游戏人物的控制，但却也和GameMode等进行合作。

游戏人物的控制是由PlayerController来实现。PlayerController可以拥有一个 Pawn 。 Pawn 是玩家在游戏中的物理表示。PlayerController负责玩家的行为。Pawn即为玩家在游戏中的人物形象。玩家为Pawn的子类。他继承Pawn。

Pawn 可以包含其自己的运动规则和其他游戏逻辑，但是该功能也可以包含在 Controller 类中。Controller有两种类型：PlayerController；AIController。PlayerController是一种玩家控制器。AIController是由计算机控制的控制器。PlayerController通过玩家的外部输入，来控制Pawn的各种行为。AIController通过各种预先设置的规则，来控制Pawn的各种行为。这就是我们所说的人工智能。游戏中的各种Boss通过AIController的控制，使游戏变得更加的智能化，赋予了他们思考的能力。Boss通过AIController的控制来实现Boss的巡视，追击，攻击，逃跑，空闲等状态的切换。

### 2.2.4 基本架构元素

基本架构元素：GameMode\(游戏模式\)；Pawn（兵）；Controller（控制器）；Camera（摄像机）；User Interfaces\(用户界面\) & HUD（平视显示信息）。

（1）GameMode\(游戏模式\)

游戏作为一个虚拟的世界，存在着自身的一些规则。通过这些规则的制定，游戏才能有序的运行，否者游戏就会陷入混乱。不同的游戏有着他们各自的游戏规则，同时他们也有一些相同的规则如：

限制玩家的数量；人物死亡后重生；游戏的暂停；物理效果的作用。

这些规则使用，限制玩家的某些行为，但对游戏的构建和运行起到了很大的的作用。这些规则除了保护玩家外，使得游戏的运行更加的贴近现实。

处理游戏类型信息有两种：GameMode 和 GameState。

“AGameMode”类定义所玩的游戏，并执行游戏规则。任何的游戏规则都必须添加到“AGameMode”类的子类中。玩家的重生，拥有的道具，游戏的时间，游戏的结束等都属于GameMode。通过GameMode中添加的规则，玩家将会依据这些规则来操作游戏。同添加新的游戏规则到GameMode中开发者，可以对游戏进行扩展。游戏可以有很多的游戏类型，这些游戏类型都是“AGameMode”类的子类，但是，在特定的时间只能使用一种游戏类型。通“UGameEngine::LoadMap\(\)”函数初始化一个游戏等级时都会实例化一个 GameMode Actor。该 Actor 定义的游戏类型将被用于该等级所持续的时间。

（2）Pawn\(兵\)

Pawn与游戏中的Actor十分类似，但是Pawn可以接受游戏玩家的输入，进而被玩家所控制，并且可通过玩家的输入，执行不同的动作。而Actor却不具备这种性质。所以在创建事物的时候，谨慎选择Pawn和Actor。

Pawn类是可由玩家或 AI 控制的。Pawn是玩家或游戏人工智能实体在游戏世界中的代表。Pawn的实体的外表，代表了游戏玩家和人工智能的外表。玩家和人工智能通过Pawn的实体，来与游戏世界进行交流。在遵循整个游戏世界的规则下，Pawn实体接受玩家和人工智能的指令，完成特定的动作。可以说Pawn是玩家和人工智能与游戏世界沟通的重要桥梁。Character 是一种特殊类型的能走动的 Pawn。Character（角色）是类人的Pawn它本身默认具有一个用于碰撞的CapsuleComponent（胶囊体组件）和CharacterMovementComponent （角色运动组件）。它可以进行基本的拟人运动，它可以平滑地在网络上复制运动，并且它具有一些动画相关的功能。

默认情况下，每个控制器在任何特定时间只控制一个 Pawn。此外，在游戏中生成的 Pawn不被控制器自动控制。

在蓝图中，使用SetActorLocation可以控制Pawn实体在游戏中的位置，通过SetActorLocation节点可以实现Pawn实体先某一方向进行移动。如果遇到游戏中的实体SetActorLocation节点将会失效。

\(3\)Controller\(控制器\)

Controller控制Pawn和Actor两种类型。Controller有两种模式：AICondtroller（人工智能控制器）和PlayerController（玩家控制器）控制器与Pawn的关系是一对一的。

Controller（控制器）不是物理性存在的，在游戏世界中不存在实体，只用于控制游戏世界中Pawn或Actor的行为。玩家通过PlayerController（玩家控制器）控制Pawn实现Pawn的各种行为。AIController（人工智能控制器）通过AI发出指令，控制Pawn实现Pawn的各种行为。控制器使用 Possess 函数控制Pawn,使用 Unpossess函数放弃控制Pawn。

PlayerController（玩家控制器）通过玩家的输入执行相应的行为（如跳跃，滑动，暂停等）。行为的执行对象一般为Pawn和Camera（相机）等。Pawn和Camer（相机）自身必须具有某些动作。

AICondtroller（玩家控制器）主要通过和游戏世界的交流而做出相应的反应（如巡视，追击，攻击，逃跑等）。PlayerController（玩家控制器）和AIController（人工智能控制器）的区别在于：PlayerController（玩家控制器）是被动接受输入执行动作，AIController（人工智能控制器）是主动根据世界环境，主动执行动作。

\(4\) Camera\(摄像机\)

游戏玩家通过Camera（摄像机）来观看游戏世界的，游戏视角即为玩家视角。因此Camera（摄像机）只和游戏玩家有关。所以游戏Camera\(摄像机\)是被PlayerController（玩家控制器）所控制的。

PlayerCameraManager（玩家摄像机管理器） 类是管理游戏摄像机的。ViewTarget 结构在 PlayerCameraManager 中定义ViewTarget向PlayerCameraManager提供理想的视角。PlayerCameraManager（玩家摄像机管理器）通过ViewTarget来调整摄像机视角，位置等其他设置。

\(5\)User Interfaces\(用户界面\) & HUD（平视显示信息）

游戏界面是游戏玩家与游戏世界进行交流重要方式。玩家通过界面来显示游戏中的人物状态等一系列信息，同时通过游戏界面的一些操作来影响游戏人物以及游戏的一些状态。 游戏界面一般由两个主要部分组成： 平头显示信息\(HUD\)和 菜单或用户界面\(UI\)。

\(HUD\)\(平视显示信息\)主要显示游戏的状态以及一些重要信息。\(HUD\)\(平视显示信息\)主要是向玩家来显示游戏的一些必要信息（如人物的血量，游戏时间，游戏得分）。\(HUD\)\(平视显示信息\)主要用来显示信息，无法对游戏产生影响。这是\(HUD\)\(平视显示信息\)与其他游戏界面的明显区别。

用户界面\(UI\)是用于玩家和游戏世界进行交互的。不同于\(HUD\)\(平视显示信息\)，用户界面\(UI\)可以触发游戏人物动作的。用户界面\(UI\)与\(HUD\)\(平视显示信息\)一样都是以平面的形式，在屏幕上显示。玩家与游戏的交流主要是，通过用户界面\(UI\)实现的。用户界面\(UI\)是通过一些标准控件和自定义控件所组成的。通过一些控件布局和程序的操作，玩家就可以和游戏进行沟通和交流了。好的游戏界面布局和整个游戏界面的系统的设计，能够很好的帮助玩家进行操作。

## 2.3 本章小结

本章主要讲解了游戏开发的环境和游戏关键的开发技术。详细讲解了开发所需的编程语言和游戏框架。

